<다형성 시작>
객체지향 프로그래밍의 대표적인 특징으로는 캡슐화, 상속, 다형성이 있다.
그 중에서 다형성은 객체지향 프로그래밍의 꽃이라 불린다.

앞서 학습한 캡슐화나 상속은 직관적으로 이해하기 쉽다. 반면에 다형성은 제대로 이해하기도 어렵고, 잘 활용하기는 더 어렵다.
하지만 좋은 개발자가 되기 위해서는 다형성에 대한 이해가 필수다.

다형성(Polymorphism)은 이름 그대로 "다양한 형태", "여러 형태"를 를 뜻한다.
프로그래밍에서 다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 뜻한다.
보통 하나의 객체는 하나의 타입으로 고정되어 있다.

그런데 다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있다는 뜻이다.

다형성을 이해하기 위해서는 크게 2가지 핵심 이론을 알아야 한다.
**다형적 참조**
**메서드 오버라이딩**

<다형적 참조>
부모 타입의 변수가 자식 인스턴스를 참조한다.
`Parent poly = new Child()`
`Child` 인스턴스를 만들었다. 이 경우 자식 타입인 `Child` 를 생성했기 때문에 메모리 상에 `Child` 와 `Parent` 가 모두 생성된다.
생성된 참조값을 `Parent` 타입의 변수인 `poly` 에 담아둔다.

**부모는 자식을 담을 수 있다.**
부모 타입은 자식 타입을 담을 수 있다.
`Parent poly` 는 부모 타입이다. `new Child()` 를 통해 생성된 결과는 `Child` 타입이다. 자바에서 부모 타입은 자식 타입을 담을 수 있다!
`Parent poly = new Child()` : 성공

반대로 자식 타입은 부모 타입을 담을 수 없다.
`Child child1 = new Parent()` : 컴파일 오류 발생

**다형적 참조**
지금까지 학습한 내용을 떠올려보면 항상 같은 타입에 참조를 대입했다. 그래서 보통 한 가지 형태만 참조할 수 있다.
`Parent parent = new Parent()`
`Child child = new Child()`
그런데 `Parent` 타입의 변수는 다음과 같이 자신인 `Parent` 는 물론이고, 자식 타입까지 참조할 수 있다.
만약 손자가 있다면 손자도 그 하위 타입도 참조할 수 있다.
`Parent poly = new Parent()`
`Parent poly = new Child()`
`Parent poly = new Grandson()` : `Child` 하위에 손자가 있다면 가능
자바에서 부모 타입은 자신은 물론이고, 자신을 기준으로 모든 자식 타입을 참조할 수 있다. 이것이 바로 다양한 형태를
참조할 수 있다고 해서 다형적 참조라 한다.

**다형적 참조와 인스턴스 실행**
앞의 그림을 참고하자. `poly.parentMethod()` 를 호출하면 먼저 참조값을 사용해서 인스턴스를 찾는다. 그리고
다음으로 인스턴스 안에서 실행할 타입도 찾아야 한다. `poly` 는 `Parent` 타입이다.
따라서 `Parent` 클래스부터 시작해서 필요한 기능을 찾는다. 인스턴스의 `Parent` 클래스에 `parentMethod()` 가 있다.
따라서 해당 메서드가 호출된다.

**다형적 참조의 한계**
arent poly = new Child()` 이렇게 자식을 참조한 상황에서 `poly` 가 자식 타입인 `Child` 에 있는
`childMethod()` 를 호출하면 어떻게 될까?
`poly.childMethod()` 를 실행하면 먼저 참조값을 통해 인스턴스를 찾는다. 그리고 다음으로 인스턴스 안에서 실행
할 타입을 찾아야 한다. 호출자인 `poly` 는 `Parent` 타입이다. 따라서 `Parent` 클래스부터 시작해서 필요한 기능을
찾는다. 그런데 상속 관계는 부모 방향으로 찾아 올라갈 수는 있지만 자식 방향으로 찾아 내려갈 수는 없다. `Parent` 는
부모 타입이고 상위에 부모가 없다. 따라서 `childMethod()` 를 찾을 수 없으므로 컴파일 오류가 발생한다.

이런 경우 `childMethod()` 를 호출하고 싶으면 어떻게 해야할까? 바로 캐스팅이 필요하다.


=>다형적 참조의 핵심은 부모는 자식을 품을 수 있다는 것이다.**
그런데 이런 다형적 참조가 왜 필요하지? 라는 의문이 들 수 있다. 이 부분은 다형성의 다른 이론들도 함께 알아야
이해할 수 있다. 지금은 우선 다형성의 문법과 이론을 익히는데 집중하자

다형성과 캐스팅
`Parent poly = new Child()` 와 같이 부모 타입의 변수를 사용하게 되면 `poly.childMethod()` 와 같이 자
식 타입에 있는 기능은 호출할 수 없다.

**캐스팅**
업캐스팅(upcasting): 부모 타입으로 변경
다운캐스팅(downcasting): 자식 타입으로 변경

**캐스팅 용어**
"캐스팅"은 영어 단어 "cast"에서 유래되었다. "cast"는 금속이나 다른 물질을 녹여서 특정한 형태나 모양으로 만드는
과정을 의미한다.
`Child child = (Child) poly` 경우 `Parent poly` 라는 부모 타입을 `Child` 라는 자식 타입으로 변경했다.
부모 타입을 자식 타입으로 변경하는 것을 다운캐스팅이라 한다. 반대로 부모 타입으로 변경하는 것은 업캐스팅이라 한다.


캐스팅의 종류
-다운캐스팅, 업캐스팅

자식 타입의 기능을 사용하려면 다음과 같이 다운캐스팅 결과를 변수에 담아두고 이후에 기능을 사용하면 된다.
```java
Child child = (Child) poly
child.childMethod();
```
하지만 다운캐스팅 결과를 변수에 담아두는 과정이 번거롭다.
이런 과정 없이 일시적으로 다운캐스팅을 해서 인스턴스에 있는 하위 클래스의 기능을 바로 호출할 수 있다.

업캐스팅
다운캐스팅과 반대로 현재 타입을 부모 타입으로 변경하는 것을 업캐스팅이라 한다.

<업캐스팅이 안전하고 다운캐스팅이 위험한 이유>
업캐스팅의 경우 이런 문제가 절대로 발생하지 않는다. 왜냐하면 객체를 생성하면 해당 타입의 상위 부모 타입은 모두함께 생성된다!
따라서 위로만 타입을 변경하는 업캐스팅은 메모리 상에 인스턴스가 모두 존재하기 때문에 항상 안전하다.
따라서 캐스팅을 생략할 수 있다.
반면에 다운캐스팅의 경우 인스턴스에 존재하지 않는 하위 타입으로 캐스팅하는 문제가 발생할 수 있다.
왜냐하면 객체를 생성하면 부모 타입은 모두 함께 생성되지만 자식 타입은 생성되지 않는다.
따라서 개발자가 이런 문제를 인지하고 사용해야 한다는 의미로 명시적으로 캐스팅을 해주어야 한다.

<다형성과 메서드 오버라이딩>
**오버라이딩 된 메서드는 항상 우선권을 가진다.**
오버라이딩은 부모 타입에서 정의한 기능을 자식 타입에서 재정의 하는것이다.
만약 자식에서도 오버라이딩 하고 손자에서도 같은 메서드를 오버라이딩을 하면 손자의 오버라이딩 메서드가 우선권을 가진다.
더 하위 자식의 오버라이딩 된 메서드가 우선권을 가지는 것이다.

지금까지 다형성을 이루는 핵심 이론인 다형적 참조와 메서드 오버라이딩에 대해 학습했다.

**다형적 참조**: 하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능
**메서드 오버라이딩**: 기존 기능을 하위 타입에서 새로운 기능으로 재정의

이 둘을 이해하고 나면 진정한 다형성의 위력을 맛볼 수 있다.



<추상 클래스>
동물(`Animal` )과 같이 부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스를 추상 클래스라 한다.
추상 클래스는 이름 그대로 추상적인 개념을 제공하는 클래스이다. 따라서 실체인 인스턴스가 존재하지 않는다. 대신에
상속을 목적으로 사용되고, 부모 클래스 역할을 담당한다.

abstract class AbstractAnimal {...}

추상 클래스는 클래스를 선언할 때 앞에 추상이라는 의미의 `abstract` 키워드를 붙여주면 된다.
추상 클래스는 기존 클래스와 완전히 같다. 다만 `new 못하는 제약이 추가된 것이다.
AbstractAnimal()` 와 같이 직접 인스턴스를 생성하지 못하는 제약이 추가된 것이다.

<추상 메서드>
부모 클래스를 상속 받는 자식 클래스가 반드시 오버라이딩 해야 하는 메서드를 부모 클래스에 정의할 수 있다.
이것을 추상 메서드라 한다.
추상 메서드는 이름 그대로 추상적인 개념을 제공하는 메서드이다.
따라서 실체가 존재하지 않고,메서드 바디가 없다.

public abstract void sound();
```
추상 메서드는 선언할 때 메서드 앞에 추상이라는 의미의 `abstract` 키워드를 붙여주면 된다.

**추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.**
그렇지 않으면 컴파일 오류가 발생한다.
추상 메서드는 메서드 바디가 없다. 따라서 작동하지 않는 메서드를 가진 불완전한 클래스로 볼 수 있다.
따라서 직접 생성하지 못하도록 추상 클래스로 선언해야 한다.

**추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.**
그렇지 않으면 컴파일 오류가 발생한다.

추상 메서드는 자식 클래스가 반드시 오버라이딩 해야 하기 때문에 메서드 바디 부분이 없다. 바디 부분을
만들면 컴파일 오류가 발생한다.

오버라이딩 하지 않으면 자식도 추상 클래스가 되어야 한다.
추상 메서드는 기존 메서드와 완전히 같다. 다만 메서드 바디가 없고, 자식 클래스가 해당 메서드를 반드시 오버라이딩 해야 한다는 제약이 추가된 것이다.

*정리*
추상 클래스 덕분에 실수로 `Animal` 인스턴스를 생성할 문제를 근본적으로 방지해준다.
추상 메서드 덕분에 새로운 동물의 자식 클래스를 만들때 실수로 `sound()` 를 오버라이딩 하지 않을 문제를 근본적으로 방지해준다.

**순수 추상 클래스
: 모든 메서드가 추상 메서드인 추상 클래스

순수 추상 클래스는 다음과 같은 특징을 가진다.
1.인스턴스를 생성할 수 없다.
2.상속시 자식은 모든 메서드를 오버라이딩 해야 한다.
3.주로 다형성을 위해 사용된다.

**2.상속하는 클래스는 모든 메서드를 구현해야 한다.**
"상속시 자식은 모든 메서드를 오버라이딩 해야 한다."라는 특징은 상속 받는 클래스 입장에서 보면 부모의 모든 메서드를 구현해야 하는 것이다.
이런 특징을 잘 생각해보면 순수 추상 클래스는 마치 어떤 규격을 지켜서 구현해야 하는 것 처럼 느껴진다.
`AbstractAnimal` 의 경우 `sound()` , `move()` 라는 규격에 맞추어 구현을 해야 한다.


